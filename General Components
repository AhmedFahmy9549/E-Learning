General Constants : 
synchronized :
               mean 1 thread at a time can access this method , this way to you dont crate 2 instance of the database in 2 diffrent thread
               at the same time because this can happen in muultithreading enviroment
 ------------------------------------------------------------------------------------------------------------------------------------------
    service :    
              A service is a component which runs in the background without direct interaction with the user. As the service has no user interface, it is not bound to the lifecycle of an activity.
              Services are used for repetitive and potentially long running operations, i.e., Internet downloads, checking for new data, data processing, updating content providers and the like.

            onStartCommand()  : Once the service is started, the onStartCommand(intent) method in the service is called. It passes in the Intent object from the startService(intent) call.
                                If startService(intent) is called while the service is running, its onStartCommand() is also called. Therefore your service needs to be prepared that onStartCommand() can be called several times
                                
         Service restart behavior:
                                  Service.START_STICKY  : 	Service is restarted if it gets terminated. Intent data passed to the onStartCommand method is null. Used for services which manages their own state and do not depend on the Intent data.

                                  Service.START_NOT_STICKY  :  Service is not restarted. Used for services which are periodically triggered anyway. The service is only restarted if the runtime has pending startService() calls since the service termination.

                                  Service.START_REDELIVER_INTENT  : Similar to Service.START_STICKY but the original Intent is re-delivered to the onStartCommand method.


           Note: You can check if the service was restarted via the Intent.getFlags() method. START_FLAG_REDELIVERY (in case the service was started with Service.START_REDELIVER_INTENT) or START_FLAG_RETRY (in case the service was started with Service.START_STICKY) is passed


    IntentServices:       
                    The IntentService is used to perform a certain task in the background. Once done, the instance of IntentService terminates itself automatically. An example for its usage would be downloading certain resources from the internet.
                    The IntentService class offers the onHandleIntent() method which will be asynchronously called by the Android system.
         
         
         
         
         If the service should be communicating back to the activity,it can receive an object of type Messenger via the Intent data it receives from the activity.
         If the Messenger is bound to a Handler in the activity, the service can send objects of type Message to the activity.
         
         Messenger also provides the method getBinder() which allows passing a Messenger to the activity. The activity can therefore send Messages to the service.
         
     
     Android Interface Definition Language AIDL :
                                                  To bind to a service which runs in a different process, you need to use Inter Process Communication (IPC) to community your the data. To do so, you need to create a AIDL file which looks similar to a Java interface, but ends with the .aidl file extension and is only allowed to extend other AIDL files.
                                                  This approach is required if you need to bind to a service running in another process, i.e., if your service is consumed by other Android applications.
------------------------------------------------------------------------------------------------------------------------------------------
    JobScheduler:
                   Used where you will want to run a task at a later point in time or under certain conditions, such as when a device is plugged into a power source or connected to a Wi-Fi network
                   The JobScheduler API performs an operation for your application when a set of predefined conditions are met
    
                    JobScheduler is implemented in the platform, which allows it to collect information about jobs
                    that need to run across all apps. This information is used to schedule jobs to run at, or around, the same time.
                    Batching job execution in this fashion allows the device to enter and stay in sleep states longer, preserving battery life.
                    
                    
    AlarmManager:
                  The AlarmManager API is another option that the framework provides for scheduling tasks.
                  This API is useful in cases in which an app needs to post a notification or set off an alarm at a very specific time.
                  You should only use this API for tasks that must execute at a specific time, but don't require the other,
                  more robust, execution conditions that JobScheduler allows you to specify, such as device idle and charging detect.


                
------------------------------------------------------------------------------------------------------------------------------------------
         SavedInstanceState: which is a Bundle object containing the activity's previously saved state.
         If the activity has never existed before, the value of the Bundle object is null.
         
          
          onSaveInstanceState() : As your activity begins to stop, the system calls the onSaveInstanceState() method so your activity can save state information to an instance state bundle. The default implementation of this method saves transient information about the state of the activity's view hierarchy, such as the text in an EditText widget or the scroll position of a ListView widget.
                                  To save additional instance state information for your activity, you must override onSaveInstanceState() and add key-value pairs to the Bundle object that is saved in the event that your activity is destroyed unexpectedly. If you override onSaveInstanceState(), you must call the superclass implementation if you want the default implementation to save the state of the view hierarchy

                                 Note: onSaveInstanceState() is not called when the user explicitly closes the activity or
                                 in other cases when finish()is called.
                                           
          onRestoreInstanceState() : When your activity is recreated after it was previously destroyed, you can recover your saved instance state from the Bundle that the system passes to your activity. Both the onCreate() and onRestoreInstanceState() callback methods receive the same Bundle that contains the instance state information.
         
------------------------------------------------------------------------------------------------------------------------------------------
     
         
   startActivityForResult()  : Sometimes you want to get a result back from an activity when it ends. For example,
                               you may start an activity that lets the user pick a person in a list of contacts; when it ends,
                               it returns the person that was selected. To do this, you call the startActivityForResult(Intent, int) method.
                               
                               The result comes back through your onActivityResult(int, int, Intent) method.
      
      
        setResult(int):    When a child activity exits, it can call setResult(int) to return data to its parent.
                           The child activity must always supply a result code, which can be the standard results RESULT_CANCELED,
                           RESULT_OK, or any custom values starting at RESULT_FIRST_USER. In addition, 
                           the child activity can optionally return an Intent object containing any additional data it wants. 
      
------------------------------------------------------------------------------------------------------------------------------------------
   Activity Life Cycle :
         Process state:
       
         Foreground (having or about to get focus)	 :   	Created - Started - Resumed
         Background (lost focus)	                   :    Paused
         Background (not visible)	                   :    Stopped              
         Empty                                       :    Destroyed
------------------------------------------------------------------------------------------------------------------------------------------

  Classes: 
  
      \\ this class for  Move and Swiped RecyclerView 
      
         new ItemTouchHelper(new ItemTouchHelper.SimpleCallback(0,ItemTouchHelper.LEFT|ItemTouchHelper.RIGHT) {
            @Override
            public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) {
                return false;
            }

            @Override
            public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) {

                viewModel.delete(adapter.getNoteAt(viewHolder.getAdapterPosition()));
                Toast.makeText(MainActivity.this, "Note Deleted", Toast.LENGTH_SHORT).show();
            }
        }).attachToRecyclerView(recyclerView);
        
 ------------------------------------------------------------------------------------------------------------------------------------------
        
        Rename of Class in java file :
         shieft+F6
------------------------------------------------------------------------------------------------------------------------------------------
    XMl File : 

              Relative Layout :
              
                                // From Parent View
                                android:layout_alignParent Top="true"
                                android:layout_alignParent Buttom="true"
                                android:layout_alignParent Right="false"
                                android:layout_alignParent Left="true"
                                android:layout_center Horizontal="true"
                                android:layout_center Vertical="true"
                                
                                // Positioning childern relative to other views
                                android:layout_toLeftOf="@id/" 
                                android:layout_toRightOf="@id/"
                                android:layout_above="@id/"
                                
                                
